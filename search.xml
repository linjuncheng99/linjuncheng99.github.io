<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring高级装配]]></title>
    <url>%2F2019%2F08%2F13%2Fspring%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[spring高级装配 spring profile 1.配置profile bean 在3.1版本中，spring引入了spring profile的功能。要使用profile，首先要将所有不同的bean定义整理到一个或多个profile中，在将应用部署到每个环境中，要保证对应得profile处于激活（active）状态。 1.1 java中配置profile 可以使用@Profile注解指定某一个bean属于哪一个profile。例如，在配置类中，嵌入式数据库的DataSource可能会配置成这样：12345678910111213141516package com.ljc.myapp;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import javax.sql.DataSource;@Configuration@Profile("dev")public class DevelopmentProfileConfig &#123; @Bean(destroyMethod = "shutdown") public DataSource dataSource()&#123; return new ... &#125;&#125; @Profile应用在类级别上，它会告诉spring这个配置类的bean只有在dev profile激活时才会创建。如果dev profile没有激活的话，那么带有@Bean注解的方法都会被忽略掉。 在spring3.1中，只能在类级别上使用@Profile注解，不过，从spring3.2开始，也可以在方法级别使用@Profile注解，与@bean一同使用。这样就能将这个bean的声明放到同一个配置类中。 1.2 在XML中配置profile 可以使用bean元素的profile属性，在XML中配置profile bean。例如，在XML中定义适用于开发阶段的嵌入式数据库DataSource bean，可以创建如下的XML文件： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation=" http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource"&gt; &lt;jdbc:script location="classpath:schema.sql"/&gt; &lt;jdbc:script location="classpath:test-data.sql"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 2.激活profile spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring。profile。active和spring。profile。default。如果设置了spring。profile。active的值，它的值就会用来确定哪个profile是激活的。但如果没有设置spring。profile。active属性的话，那么spring就会查找spring。profile。default的值，如果都没有设置的话，那就没有激活的profile，那就只能创建那些没有定义在profile的bean。 条件化的bean 如果希望一个或者多个bean只有在应用的类路径下包含特定的库时才创建。或者希望某个bean只有在当另外的特定的bean也声明了之后才会创建，还可能要求某个环境变量设置之后，才会创建某个bean。在spring4之前很难实现这种操作，但是spring4引入了一个新的注解@Conditionnl，它可以用到带有@Bean注解的方法上，弱国给定的结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 1.条件化的配置bean12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean()&#123; return new MagicBean();&#125; 可以看到，@Conditional给定了条件–MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比; 123public interface Condition &#123; boolean matchs(ConditionContext ctxt, AnnotatedTypeMetadata metadata)&#125; 如果 matchs（）方法返回true，那么就会创建带有@Conditional注解的bean，如果返回false，则不会创建这些bean 2.检查是否存在某属性 在本例中，我们需要创建Condition的实现，并根据环境中是否存在magic属性来做决策：12345678910111213141516package com.ljc.myapp;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.type.AnnotatedTypeMetadata;import sun.tools.java.Environment;public class MagicExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env=context.getEnvirment; return env.containsProperty("magic"); &#125;&#125; matchs()方法很简单但功能强大，它通过给定的ConditionContext对象得到Environment对象，并用这个对象检查环境是否存在magic属性，属性的值是什么无所谓，只要满足条件就可以，满足就返回true，否则返回false ConditionContext接口： 12345678910111213public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); @Nullable ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); @Nullable ClassLoader getClassLoader();&#125; 通过ConditionContext接口，可以做到如下几点： 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义 借助getBeanFactory()返回的ConfigurableListableBeanFactory 检查bean是否存在，甚至探查bean的属性 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源 借助getClassLoader()返回的ClassLoader加载并检查类是否存在 AnnotatedTypeMetadata接口： 123456789101112131415public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 借助isAnnotated方法，能够判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他方法，能够检查@Bean注解的方法上其他的注解的属性 处理自动装配的歧义性 当发生歧义性时，spring提供了多种可选的方案来解决这样的问题。可以将某个bean设为首选（primary）的bean，或者使用限定符（qualifier）来帮助spring将可选的范围缩小到只有一个。 1.标示首选的bean 下面的代码显示了如何将@Component注解的bean声明为首选的bean 123@Component()@Primarypublic class SgtPeppers implements CompactDisc &#123; 通过java代码显示的声明，那么@Bean的方法如下： 123456@Bean@Primary@Conditional(MagicExistsCondition.class)public MagicBean magicBean()&#123; return new MagicBean();&#125; 如果使用XML配置的话，bean元素有一个primary属性用来指定首选的bean： 123&lt;bean id="CompactDisc" class="com.ljc.soundsystem.SgtPeppers" primary="true"/&gt; 2.限定自动装配的bean 确保将CompactDisc注入到setCompactDisc中：12345@Autowired @Qualifier("CompactDisc") public void setCompactDisc(CompactDisc compactDisc)&#123; this.compactDisc=compactDisc; &#125; bean的作用域 在默认情况下，spring应用上下文中的所有bean都是作为以单例（singleton）模式创建的，也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。spring定义了多种作用域，可以基于这些作用域创建bean，包括： 单例（singleton）：在整个应用中，只创建bean一个实例； 原型（propotype）：每次注入或者通过spring应用上下文获取的时候，都会创建一个新的bean实例； 会话（session）：在Web应用中，为每个会话创建一个bean； 请求（Rquest）：在web应用中，为每个请求创建一个bean； 单例是默认的，如果选择其他的作用域，要使用@Scope注解，可以和@Bean或@Component注解一起使用]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的核心---spring容器]]></title>
    <url>%2F2019%2F08%2F12%2FSpring%E7%9A%84%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[spring的核心—spring容器spring基本概念 什么是spring框架 Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 spring的体系结构 spring框架是一个分层架构，包含一系列的功能要素，被分为大约20个模块。这些模块分为Core Container，Data Access/Integration,Web,AOP,测试部分 让我们逐一浏览spring模块 spring核心容器—管理着bean的创建，配置和管理 bean 工厂：为spring提供DI的功能 应用上下文：提供了配置spring的方式 spring的AOP模块—面向切面编程 AOP：帮助应用对象解耦 数据访问与集成 JDBC：抽象了板式代码，使数据库代码变得简洁明了 ORM：对许多流行的ORM框架进行了集成，例如Hibernate。spring的事务管理支持所有的ORM框架以及JDBC JMS：使用消息以异步的方式与其他应用集成，从spring3.0开始，本模块还包含对象到XML映射的特性 Web与远程调用—MVC（Model-View-Controller）Instrumentation 提供了为JVM添加代理的功能。具体来讲，为Tomcat提供了一个植入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样 测试 为使用JNDI，Servlet和Portlet编写单元提供了一些列的mock对象实现 装配Bean 在XML中进行显示配置 在java中进行显示配置 隐式的bean发现机制和自动装配 自动化装配bean：组件扫描和自动装配1.创建可被发现的bean 1.1 CompactDisc接口定义了CD的概念 12345package com.ljc.soundsystem;public interface CompactDisc &#123; void play();&#125; 1.2 带有@Component注解的CompactDisc实现类SgtPeppers 12345678910111213package com.ljc.soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc &#123; private String title="Sgt.Pepeers's Lonely Hearts Club Band"; private String artist="The Beatles"; public void play() &#123; System.out.println("Playing"+title+"by"+artist); &#125;&#125; @Compoment注解：表明该类会作为组件类，并告知spring要为这个类创建bean 1.3 @ComponentScan注解启用了组件扫描—组件扫描默认是不开启的，需要显示配置一下spring，从而命令它去寻找带有@Component注解的类，并为其创建bean 123456789package com.ljc.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 2. 为组件扫描的bean命名 2.1&nbsp;&nbsp;spring给所有的bean都有一个ID。在前面的例子中，我们没有为SgtPeppersbean设置ID，但spring会根据类名为其指定一个ID，为sgtPeppers，也就是类名的第一个字母变为小写 2.2&nbsp;&nbsp;方法1：将期望的ID值传递给@Component注解。例如想让这个标识为lin，只需要像下面配置： 123@Component("lin")public class SgtPeppers implements CompactDisc &#123; ...&#125; 2.3&nbsp;&nbsp;方法2：不适用@Component注解，而是使用java依赖注入规范中的@Named注解为bean设置ID 3.通过为bean添加注解实现自动装配 3.1&nbsp;&nbsp;通过自动装配，将一个CompactDisc注入到CDPlayer之中 1234567891011121314151617181920package com.ljc.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig &#123; private CompactDisc cd; @Autowired public CDPlayerConfig(CompactDisc cd)&#123; this.cd=cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 3.2&nbsp;&nbsp;构造器上加了@Autowired注解，表明当spring创建CDPlayerConfigbean时，会通过这个构造器来进行实例化并传入一个可以设置给CompactDisc类型的bean。@Autowired不仅适用构造器，也适用其他方法 3.3&nbsp;&nbsp;如果没有匹配的bean，spring会抛出一个异常。为了避免异常，可以将@Autowired的required属性设为false： 1234@Autowired(required = false) public CDPlayerConfig(CompactDisc cd)&#123; this.cd=cd; &#125; -3.4&nbsp;&nbsp;可以用@Inject替换@Autowired，spring可以同时支持两种 通过java代码装配bean1.创建配置类12345678package com.ljc.soundsystem;import org.springframework.context.annotation.Configuration;@Configurationpublic class CDPlayerConfig &#123;&#125; @Configuration注解表明这个类是一个配置类，该类包含在spring应用上下文如何创建bean的细节 2.声明简单的bean-2.1&nbsp;在javaConfig中声明bean，需要编写一个方法，这个方法负责创建所需类型的实例，然后给这个方法添加@Bean注解。例如，下面的代码声明了CompactDisc bean： 1234@Bean public CompactDisc sgtPeppers()&#123; return new SgtPeppers(); &#125; -2.2&nbsp;@Bean注解会告诉spring这个方法会返回一个对象，该对象要注册为spring上下文中的bean。默认下，bean的ID与带有@Bean注解的方法一样，本例中，bean的ID为sgtPeppers。 3.借助javaConfig实现注入 通过XML装配bean1.创建XML配置规范12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context"&gt; &lt;!-- configuration details go here--&gt;&lt;/beans&gt; 以bean元素为根，需要在顶部声明多个XML模式（XSD）文件，这些文件定义了配置spring的XML元素 2.声明一个简单的bean 2.1&nbsp;bean元素相当于JavaConfig的@Bean注解，可以按照如下方法声明一个bean：1&lt;bean class="com.ljc.soundsystem.SgtPeppers"/&gt; -因为没有给定ID，所以这个bean会根据类名来进行命名。在本例中，bean的ID将会是“soundsystem.SgtPeppers#0”.其中#0是一个计数的形式，用来区分相同类型的bean。如果声明了另外一个SgtPeppers，并且没有明确的标识，那么它会自动得到ID：“soundsystem.SgtPeppers#1” 2.2更好的方法是借助id属性，为每一个bean设置成自己选择的ID： 1&lt;bean id="CompactDisc" class="com.ljc.soundsystem.SgtPeppers"/&gt; 3.借助构造器初始化注入bean 构造器注入，有两种基本的配置方案：a.constructor-arg元素&nbsp;&nbsp;b.使用spring3.0引入的c-命名空间 3.1已经声明了SgtPeppers bean，并且SgtPeppers类实现了CompactDisc接口，所以我们已经有了一个可以注入到CDPlayer bean的bean。只需要在XML中声明CDPlayer并通过ID引用SgtPeppers： 123&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayerConfig"&gt; &lt;constructor-arg ref="CompactDisc"/&gt; &lt;/bean&gt; &nbsp;&nbsp;当spring遇到这个bean元素时，它会创建一个CDPlayer实例。constructor-arg会告诉spring要将一个ID为CompactDisc的bean引用传递到CDPlayer的构造器中 3.2 也可以使用费c-命名空间，必须在XML的顶部声明： 123456&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:c="http://www.springframework.org/schema/c" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context"&gt; 声明如下： 12&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayerConfig" c:cd-ref="CompactDisc"/&gt; 4.设置属性 4.1 CDPlayer如下：1234567891011121314151617package com.ljc.soundsystem;import org.springframework.beans.factory.annotation.Autowired;public class CDPlayer implements MediaPlayer&#123; private CompactDisc compactDisc; @Autowired public void setCompactDisc(CompactDisc compactDisc)&#123; this.compactDisc=compactDisc; &#125; public void play()&#123; compactDisc.play(); &#125;&#125; &nbsp;&nbsp;对强依赖使用构造器注入，对可选性的以来使用属性注入。将其声明为spring bean： 1234&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="CompactDisc"/&gt; &lt;/bean&gt; &nbsp;&nbsp;property元素为属性的Setter方法提供的功能与constructor-arg元素为构造器提供的功能是一样的。在本例中，它引用了ID为compactDisc的bean（通过ref属性），并将其注入到compactDisc属性中（通过setCompactDisc（）方法） 4.2 上文说过，spring为constructor-arg元素提供了c-命名空间，同样，spring提供了更加简洁的p-命名空间作为property的代替方案。为了启用p-命名空间，必须要在XML的顶部声明： 1xmlns:p="http://www.springframework.org/schema/p" 可以使用p-命名空间，按照如下的方式装配compactDisc属性：123&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayer" p:compactDisc-ref="CompactDisc"/&gt; 小结 建议尽可能使用自动化配置，以避免显示配置所带来的维护成本。但是，当我们确实需要显示配置的话，应该优先选择基于java的配置，它比基于XML的配置更加强大，类型安全并且易于重构。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F08%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[java的学习路线基础知识 编程语言：java 基本算法 基本网络知识：TCP/IP HTTP/HTTPs 基本的设计模式 工具方面 操作系统：Linux 代码管理：SVN/git 持续集成（CI/CD）：jenkins java项目管理工具：maven 框架方面应用层框架 ssh：spring+structs+hibernate ssm：spring+springMVC+mybatis springboot 中间件 MQ 消息队列 RPC 通信框架 elasticserach 搜索引擎 数据库 SQL：MYSQL/oracle NOSQL： Redis mongodb 架构方面分布式/微服务 springcloud dubbo 虚拟化/容器化技术 Docker 容器 K8S kubernetes 关注源码/性能 JDK 源码以及设计思想 spring 源码 JVM 细节 高并发/高可用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
