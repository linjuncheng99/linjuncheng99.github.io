<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springMVC的高级技术]]></title>
    <url>%2F2019%2F08%2F18%2FspringMVC%E7%9A%84%E9%AB%98%E7%BA%A7%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[渲染Web视图]]></title>
    <url>%2F2019%2F08%2F18%2F%E6%B8%B2%E6%9F%93Web%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[本章主要内容： 将数据模型渲染为HTML 使用JSP视图 理解视图解析 将控制器中请求处理的逻辑和视图中的渲染实现解耦是Spring MVC 的一个重要特性。如果控制器中的方法直接负责产生HTML的话，就很难在不影响请求处理逻辑的前提下，维护和更新视图。控制器方法和视图的实现会在模型内容上达成一致，这是两者的最大关联，除此之外，两者应该保持足够的距离。但是，如果控制器只通过逻辑视图来了解视图的话，那Spring该如何确定使用哪一个视图实现来渲染模型呢？这就是Spring视图解析器的任务了 Spring MVC 定义了一个名为ViewResolver的接口，它大致如下所示： 1234567package org.springframework.web.servlet;import java.util.Locale;public interface ViewResolver &#123; View resolveViewName(String var1, Locale var2) throws Exception;&#125; 当给resolveViewName()方法传入一个视图名和Locale对象时，它会返回一个View实例。View是另外一个接口： 123456789public interface View &#123; String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + ".responseStatus"; String PATH_VARIABLES = View.class.getName() + ".pathVariables"; String SELECTED_CONTENT_TYPE = View.class.getName() + ".selectedContentType"; String getContentType(); void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception;&#125; View接口的任务就是接受模型以及Servlet的request和response对象，并将输出结果渲染到response中 创建JSP视图Spring提供了两种支持JSP视图的方式： InternalResourceViewResolver会将视图名解析为JSP文件。另外，如果在JSP页面中使用了JSP标准签库（JavaServer Pages Standard Tag library，JSTL）的话，InternalResourceViewResolver能够将视图名解析为JstlView形式的JSP文件，从而将JSTL本地化和资源bundle变量暴露给JSTL的格式化(formatting)和信息(message)标签 •Spring提供了连个JSP标签库，一个用于表单到模型的绑定，另一个提供了通用的工具类特性 1.配置使用于JSP的视图解析器 有一些视图解析器，如ResourceBundleViewResolver会直接将逻辑视图名称映射为特定的View接口实现，而InternalResourceViewResolver所采取的方式并不那么直接。它遵循一种约定，会在视图名称上添加前缀和后缀，进而确定一个Web应用中视图资源的物理路径。 1.1 java配置123456789//配置JSP视图解析器 @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver=new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; 1.2 使用XML的Spring配置：1234&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver" p:prefix="/WEB-INF/views/" p:suffix=".jsp"/&gt; InternalResourceViewResolver配置就绪后，它就会将逻辑视图名解析为JSP文件，如下所示： home将会解析为”/WEB-INF/views/home.jsp” productList将会解析为”/WEB-INF/views/productList.jsp” 2. 使用Spring的JSP库2.1 将表单绑定到模型上 Spring中的表单绑定JSP标签库包含了14个标签，它们中的大多数都是用来渲染HTML中的表单标签。但是，它们与原生HTML表单标签的区别在于它们会绑定模型中的一个对象，能够根据模型中对象的属性填充值。标签库还包含了一个为用户展示错误的标签，它会将错误信息渲染到最终的HTML上。 为了使用表单绑定标签，需要在JSP页面中对其进行声明： 1&lt;%@ taglib prefix="sf" uri="http://www.springframework.org/tags/form" %&gt; 在注册JSP中使用这些标签后，代码如下： 1234567&lt;sf:form method="post" commandName="spitter"&gt; First Name: &lt;sf:input path="firstName"/&gt;&lt;br/&gt; Last Name: &lt;sf:input path="lastName"/&gt;&lt;br/&gt; Username: &lt;sf:input path="username"/&gt; Password: &lt;sf:input path="password"/&gt; &lt;input type="submit" value="Register"/&gt;&lt;/sf:form&gt; sf:form会渲染一个HTML的form标签，但它也会通过commandName属性构建针对某个模型对象的上下文信息。在其他的表单绑定标签中，会引用这个模型对象的属性。需要注意的是，我们将commandName属性设置为spitter，因此，在模型中必须有一个key为spitter的对象，否则的话，表单不能正常渲染（会出现JSP错误）。这意味着我们需要修改一下SpitterController，以确保模型中存在spitter为key的Spitter对象：12345@RequestMapping(value = "/register", method = RequestMethod.GET)public String showRegistrationrForm(Model model)&#123; model.addAttribute(new Spitter()); return "registerForm";&#125; 回到这个表单，前三个输入域将HTMLinput标签改成了sf:input。这个标签会渲染成一个HTMLinput标签，其中type属性设置为”text”。我们在这里设置了path属性，input标签的value属性值将会设置为模型对象中path属性所对应的值。对于password输入域，我们使用sf:password来代替sf:input。sf:password与sf:input类似，但是它所渲染的HTML的input标签中，会将type属性设置为password，这样当输入的时候，它的值不会明文显示。 2.2 展现错误 如果存在校验错误的话，请求中会包含错误的详细信息，这些信息是与模型数据放到一起的。我们所需要做的就是到模型中将这些数据抽取出来，并展现给用户。sf:errors能够让这项任务变得简单： 1234567891011&lt;sf:form method="post" commandName="spitter"&gt; First Name: &lt;sf:input path="firstName"/&gt; &lt;sf:errors path="firstName"/&gt;&lt;br/&gt; Last Name: &lt;sf:input path="lastName"/&gt; &lt;sf:errors path="lastName"/&gt;&lt;br/&gt; Username: &lt;sf:input path="username"/&gt; &lt;sf:errors path="username"/&gt;&lt;br/&gt; Password: &lt;sf:password path="password"/&gt; &lt;sf:errors path="password"/&gt;&lt;br/&gt; &lt;input type="submit" value="Register"/&gt;&lt;/sf:form&gt; 在这里sf:errors的path属性设置成其对应需要展示的sf:input的path属性值，也就指定了要显示Spitter模型对象中哪个属性的错误信息。如果绑定的属性没有任何错误的话，那么sf:errors不会渲染任何东西。现在，我们已经可以为用户展现错误信息了，这样他们就能够修正这些错误了。我们还可以更进一步，修改错误的样式，使其更加突出显示。为了做到这一点，可以设置其cssClass属性： 1234567891011&lt;sf:form method="post" commandName="spitter"&gt; First Name: &lt;sf:input path="firstName"/&gt; &lt;sf:errors path="firstName" cssClass="error"/&gt;&lt;br/&gt; Last Name: &lt;sf:input path="lastName"/&gt; &lt;sf:errors path="lastName" cssClass="error"/&gt;&lt;br/&gt; Username: &lt;sf:input path="username"/&gt; &lt;sf:errors path="username" cssClass="error"/&gt;&lt;br/&gt; Password: &lt;sf:password path="password"/&gt; &lt;sf:errors path="password" cssClass="error"/&gt;&lt;br/&gt; &lt;input type="submit" value="Register"/&gt;&lt;/sf:form&gt; 2.3 创建URL s:url标签的主要任务是创建URL，然后将其赋值给一个变量或者渲染到响应中。它是JSTL中c:url标签的替代者，但是它有自己的特殊技巧。按照其最简单的形式s:url会接受一个相当于Servlet上线文的URL，并在渲染的时候预先添加上Servlet上下文路径。例如： 1&lt;a href="&lt;s:url value="/spitter/register"/&gt;"&gt;Register&lt;/a&gt; 另外，还可以使用s:url创建URL，并将其赋值给一个变量供模板在稍后使用： 12&lt;s:url value="/spitter/register" var="registerUrl"&gt;&lt;/s:url&gt;&lt;a href="$&#123;registerUrl&#125;"&gt;Register&lt;/a&gt; 默认情况下，URL是在页面作用域内创建的。但是通过设置scope属性，我们可以让s:url在应用作用域内、会话作用域内或请求作用域内创建URL： 1&lt;s:url value="/spitter/register" var="registerUrl" scope="request"/&gt; 如果希望在URL上添加参数的话，那么你可以使用s:param标签:1234&lt;s:url value="/spitter/register" var="registerUrl" scope="request"&gt; &lt;s:param name="max" value="60"/&gt; &lt;s:param name="count" value="20"/&gt;&lt;/s:url&gt;]]></content>
      <categories>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构建Spring Web应用程序]]></title>
    <url>%2F2019%2F08%2F17%2FWeb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[spring MVC基于模型-控制器-视图（Model-Controller-View，MVC）模式实现，它能帮助你构建像spring框架的灵活和松耦合的Web应用程序。 spring MVC起步 Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供了构建 Web 应用程序的全功能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的Spring MVC框架 1. 跟踪spring MVC的请求 具体步骤： 第一步：发起请求到前端控制器(DispatcherServlet)。DispatcherServlet的任务是将请求发送给spring MVC控制器（controller），控制器是一个用于处理请求的spring组件。 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）。应用程序中可能有多个控制器，DispatcherServlet需要知道应该将请求发送到哪个控制器，所以DispatcherServlet会查询一个或者多个处理器映射（hander mapping）来确定发送到哪一个控制器。 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 2.搭建spring MVC2.1 配置DispatcherServlet 传统的方式是会配置在web.xml文件中，这个文件会放到应用的WAR包里面，但在这里使用java将DispatcherServlet配置在Servlet容器中，而不再使用xml文件：12345678910111213141516171819202122package web.config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class SpittrWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer &#123; @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[0]; &#125; //指定配置类 @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[0]; &#125; //将DispatcherServlet映射到“/” @Override protected String[] getServletMappings() &#123; return new String[0]; &#125;&#125; 2.2 启用springMVC 我们能创建一个简单的带有@EnableWebmvc注解的类：123456789package web.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@EnableWebMvcpublic class WebConfig &#123;&#125; 这个类可以运行起来，也可以启用springMVC，但它还存在很多问题 没有配置视图解析器。如果这样，spring会默认使用BeanNameView-Resolver，这个试图解析器会查找ID与视图名称匹配的bean，并且查找的bean要实现View接口 没有启用组件扫描。这样的结果就是，spring只能找到显试声明在配置类的控制器 DispatcherServlet会映射为应用默认的Servlet，所以它会处理所有的请求，包括对静态资源的访问，达不到想要的效果 因此我们需要在WebConfig这个最小配置类中再加一些东西： 12345678910111213141516171819202122232425262728293031package web.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration@EnableWebMvc //启用spring MVC @ComponentScan("web.config") //启用组件扫描public class WebConfig extends WebMvcConfigurerAdapter &#123; //配置JSP视图解析器 @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver=new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; //配置静态资源的处理 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125;&#125; Spittr应用介绍 Spittr应用有两个基本的领域概念：Spitter(应用的用户)和Spittle(用户发布的简短状态更新)。当我们在书中完善Spittr应用的功能时，将会介绍这两个概念。在本章中，我们会构建应用的Web层，创建展现Spittle的控制器以及处理用户注册为Spitter的表单。 编写基本的控制器 在spring MVC中，控制器只是在方法上添加了@RequestMapping注解，下面写一个超级简单的控制器类HomeController：123456789101112131415package web.config;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller //声明一个控制器类public class HomeController &#123; //处理对“/”的get的请求 @RequestMapping(value = "/",method = RequestMethod.GET) public String home()&#123; return "homg"; //视图名为home &#125;&#125; home()方法带有 @RequestMapping注解，vaule属性指定了所要处理的路径，method属性细化了所要处理的HTTP方法，它返回了一个String类型的home，这个home被spring MVC解析为要渲染的视图名称，DispatcherServlet会要求视图解析器将这个逻辑名称渲染为实际的视图，在这里视图会被解析为“WEB-INF/views/home.jsp”路径的JSP： 1234567891011121314&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Spittr&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="&lt;c:url value="/resources/style.css"/&gt;"&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Welcome to Spitrr&lt;/h1&gt; &lt;a href="&lt;c:url value="/spittles"/&gt;"&gt;Spittles&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 1. 测试控制器123456789101112131415161718192021package web.config;import org.junit.jupiter.api.Test;import org.springframework.test.web.servlet.MockMvc;import static org.springframework.test.web.servlet.setup.MockMvcBuilders.*;import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;public class HomeControllerTest &#123; @Test public void testHomePage() throws Exception &#123; //搭建MockMve HomeController controller=new HomeController(); MockMvc mockMvc=standaloneSetup(controller).build(); //对“/”执行GET请求 mockMvc.perform(get("/")).andExpect(view().name("home")); &#125;&#125; 2. 传递模型数据到视图中 需要定义一个数据访问的Repository，为了实现解耦以及数据库访问的细节中，将其定义为一个接口，如下的SpittleRepository：12345678package web.data;import java.util.List;import web.Spittle;public interface SpittleRepository &#123; List&lt;Spittle&gt; findSpittle(long max, int count);&#125; 如果要获取最近的20个Spittle对象，那么只需调用这样调用：List recent = spittleRepository.findSpittles(Long.MAX_VALUE, 20); 下面对Spittle进行定义：1234567891011121314151617181920212223242526272829303132333435363738package web;import java.util.Date;import org.apache.commons.lang3.builder.EqualsBuilder;import org.apache.commons.lang3.builder.HashCodeBuilder;public class Spittle &#123; private final Long id; private final String message;// 消息 private final Date time;// 时间戳 private Double latitude; private Double longitude; public Spittle(String message, Date time) &#123; this(message, time, null, null); &#125; public Spittle(String message, Date time, Double latitude, Double longitude) &#123; this.id = null; this.message = message; this.time = time; this.latitude = latitude; this.longitude = longitude; &#125; @Override public boolean equals(Object that) &#123; return EqualsBuilder.reflectionEquals(this, that, "id", "time"); &#125; @Override public int hashCode() &#123; return HashCodeBuilder.reflectionHashCode(this, "id", "time"); &#125; //getters and setters&#125; 接受请求的输入Spring MVC提供了如下方式供客户端传递数据到控制器处理方法： 查询参数：Query parameters 表单参数: Form parameters 路径变量：Path variables 1. 处理查询参数Spittr应用的一个需求就是要对spittle列表分页展示，但是SpittleController仅仅展示最近的spittle。如果要让用户可以每次得到一页的spittle记录，那么就需要让用户可以通过某种方式将他们想看的spittle记录的参数传递到后台。 在浏览spittle时，如果想要查看下一页的spittle，那么就需要传递比当前页的最后一个spittle的id小一位的id，也可以传递想要展示的spittle的数量。 为了实现分页，需要编写一个控制器满足： before参数，结果中的spittle的id都要在这个参数之前； count参数，结果中要包含的spittle的个数 测试方法： 123456@RequestMapping(method=RequestMethod.GET)public List&lt;Spittle&gt; spittles( @RequestParam(value="max", defaultValue=MAX_LONG_AS_STRING) long max, @RequestParam(value="count", defaultValue="20") int count) &#123; return spittleRepository.findSpittles(max, count);&#125; 2. 通过路径参数接受输入假设现在应用需要展示单独的一篇Spittle，那么就需要一个id作为查询参数，对应的处理方法可以是： 12345678@RequestMapping(value="show", method=RequestMethod.GET)public String showSpittle( @RequestParam("spittle_id") long spittleId, Model model ) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 为了满足路径参数，Spring MVC允许在@RequestMapping路径中使用占位符（需要用大括号包围），下面是使用占位符来接受一个id作为路径的一部分： 12345678@RequestMapping(value="/&#123;spittleId&#125;", method=RequestMethod.GET)public String spittle( @PathVariable("spittleId") long spittleId, Model model ) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; spittle()方法的spittleId入参使用了@PathVariable(“spittleId”)注解，表明请求中占位符位置的值都会被传送到handler的spittleId参数。@RequestMapping中value属性的占位符必须和@PathVariable包裹的参数一致。如果@PathVariable中没有给定参数，那么将默认使用入参的册数参数名。即可以使用下面的方法： 12345678@RequestMapping(value="/&#123;spittleId&#125;", method=RequestMethod.GET)public String spittle( @PathVariable long spittleId, Model model ) &#123; model.addAttribute(spittleRepository.findOne(spittleId)); return "spittle";&#125; 3.表单3.1 处理表单 对于表单有两种处理方式：展示表单以及处理用户提交的表单数据。在Spittr中，需要提供一个供新用户进行注册的表单。 SpitterController：展示用户注册表单 12345678910111213141516package web.config;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controller@RequestMapping("/spitter")public class SpittleController &#123; // 处理来自/spitter/register的get请求 @RequestMapping(value = "/register", method = RequestMethod.GET) public String showRegistrationForm() &#123; return "registerForm"; &#125;&#125; showRegistrationForm方法的@RequestMapping注解，以及类级别的注解@RequestMapping，表明了这个方法会处理来自/spitter/register的get请求，该方法仅仅返回了一个名为registerForm的逻辑视图。根据之前在InternalResourceViewResolver中的配置，这个逻辑视图会导向到/WEB-INF/views/registerForm.jsp该界面。 3.2 编写表单处理控制器 在处理POST请求时，控制器需要接受表单数据并且将这些数据存储为一个Spitter对象。为了避免重复提交，应该重定向到一个新的界面：用户信息页。在处理post请求时，一个聪明的做法就是在处理完成后发送一个重定向的请求，从而可以避免重复提交。 下面来实现控制器方法，从而可以处理注册请求。 1234567891011121314151617private SpitterRepository spitterRepository; public SpitterController() &#123; &#125; // 注入SpitterRepository @Autowired public SpitterController(SpitterRepository spitterRepository) &#123; this.spitterRepository = spitterRepository; &#125; public String processRegistration(Spitter spitter) &#123; // 保存Spitter spitterRepository.save(spitter); // 重定向到新的页面 return "redirect:/spitter/" + spitter.getUsername(); &#125; processRegistration方法使用Spitter对象作为入参，该对象的属性会从请求中填充。该方法中调用了spitterRepository的save方法对Spitter对象进行存储。最后返回了一个带有redirect:的字符串。 当InternalResourceViewResolver遇到redirect:时，它会自动地将其当做一个重定向请求，从而可以重定向到用户详情页面，如/spitter/xiaoming。 同时，InternalResourceViewResolver也可以识别前缀forward:，这种情况下，请求会被转向到给定的URL地址。 3.4 参数检验从Spring3.0开始，Spring支持Java校验api，从而可以从而可以不需要添加其他配置，仅仅需要有一个Java API 的实现，如Hibernate Validator。 Java Validation API定义了许多注解，可以使用这些注解来约束参数的值，所有的注解都在包javax.validation.constraints中。]]></content>
      <categories>
        <category>springMVC</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向切面的spring]]></title>
    <url>%2F2019%2F08%2F15%2F%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84spring%2F</url>
    <content type="text"><![CDATA[什么是面向切面编程–AOP AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.定义AOP术语1.1 通知（advice）–切面的工作 通知定义了切面是什么以及切面何时使用，除了描述了切面要完成的工作，还解决了何时执行这个工作的问题。spring切面可以应用5中类型的通知： 前置通知（Before）：在目标调用之前调用通知功能； 后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么； 返回通知（After-returning）：在目标方法成功之后调用通知； 异常通知（After-throwing）：在目标方法抛出异常之后调用通知； 环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和之后执行自定义的行为； 1.2 连接点（Join point） 连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法，抛出异常时，甚至修改一个字段时，切面代码可以利用这些点插入到应用的正常流程中，并添加新的行为。 1.3 切点（Pointcut） 切点的定义会匹配通知所要织入的一个或多个连接点。通常使用明确的类名称和方法名称来指定这些切点。 1.4 切面（Aspect） 切面是通知和切点的结合，通知和切点共同定义了切面的全部内容–它是什么，在何时，何处完成其功能。 1.5 引入（Instruction） 引入允许我们向现有的类添加新方法和属性。 1.6 织入（Weaving） 织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点织入到目标对象中，在目标对象的生命周期有多个点可以织入： 编译期：切面在目标类编译时织入，这时需要特定的编译器； 类加载期：切面在目标类加载到JVM时被织入，这种方式需要特定的类加载器； 3.运行期：切面在应用运行的某个期间织入； 2.spring对AOP的支持2.1 spring通知是java编写的 可以用与普通java开发一样的IDE来开发切面，而且，定义通知的所应用的切点通常都会使用注解或者spring配置文件里的XML编写。 2.2 spring在运行时通知对象 spring在运行期间把切面织入到spring管理的bean中 2.3 spring只支持方法级别的连接点 通过切点来选择连接点 在spring AOP中要用AspectJ的切点表达式来定义切点，下表列出了spring AOP所支持的AspectJ切点指示器： AspectJ指示器 描述 arg() 限制连接点匹配参数为指定类型的执行方法 @args() 限制连接点匹配参数为指定注解的执行方法 execution() 用于匹配是连接点的方法 this() 限制连接点匹配AOP代理的bean引用为指定类型的类 target() 限制连接点匹配对象为制定类型的类 @target() 限制连接点匹配特定的执行对象，这些对象对应的类要有指定类型的注解 within() 限制连接点匹配指定的类型 @within() 限制连接点匹配指定注解所标注的类型 @annotation 限定匹配带有指定注解的连接点 在spring中尝试使用其他指示器时，会抛出IllegalArgument-Exception异常。注意，只有execution指示器是用来实际匹配的，其他指示器都是用来限制匹配的，这说明我们在编写切点定义时execution是常用的指示器。 1. 编写切点 定义了一个Performance接口：12345package com.ljc.concert;public interface Performance &#123; public void perform();&#125; 假设想编写Performance的perform（）方法触发的通知，下面展示了一个切点表达式，这个表达式能够设置当perforn（）执行时触发通知的调用。 1execution(*com.ljc.concert.Performance.perform(..)) 使用execution指示器来选择Performance的perform方法。方法表达式以*开始，表明不关心返回值的类型，然后指定了全限类名和方法名，对于参数列表用(..)表示表明切点要选择任意的perform方法，无论该方法的入参是什么。 假设需要配置的切点仅仅匹配concert包，可以使用within()限制匹配：1execution(*com.ljc.concert.Performance.perform(..))&amp;&amp;within(com.ljc.concert.*) 使用&amp;&amp;操作符把execution和within连接在一起形成与（and）关系，注意：因为&amp;在XML中有特殊的含义，所以在spring的XML配置中描述切点时，可以使用and代替&amp;&amp; 2. 在切点中选择bean 除了上表中的指示器，spring还引入了一个新的bean（）指示器，它允许我们在切点表达式中用bean的ID来表示bean。bean（）使用bean ID或者bean名称来限制切点只匹配特定的bean， 使用注解来创建切面1.定义切面 Audience类使用@Aspect进行了注解，表明Audience不仅是一个POJO，还是一个切面。Audience类中的方法都使用注解来定义切面的具体行为1234567891011121314151617181920212223242526272829303132 package com.ljc.concert;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;@Aspectpublic class Audience&#123; //表演之前 @Before("execution(**com.ljc.concert.Performance.perform(..))") public void silenceCellPhones()&#123; System.out.println("Silencing Cell Phones..."); &#125; @Before("execution(**com.ljc.concert.Performance.perform(..))") public void takeSeats() &#123; System.out.println("Taking seats..."); &#125; //表演之后 @AfterReturning("execution(**com.ljc.concert.Performance.perform(..))") public void applause()&#123; System.out.println("Clap..."); &#125; //表演失败之后 @AfterThrowing("execution(**com.ljc.concert.Performance.perform(..))") public void demandRefound()&#123; System.out.println("Demanding a refund..."); &#125;&#125; Aspect提供了5个注解来定义通知: 注解 通知 @After 通知方法会在目标方法返回或者抛出异常后调用 @AfterReturning 通知方法会在目标方法返回后调用 @AfterThrowing 通知方法会在异常抛出后调用 @Around 通知方法会将目标方法封装起来 @before 通知方法会在目标方法调用之前执行 上面的切点表达式我们重复了4遍，其实我们可以只定义一次，然后在每次使用它时调用它就可以了：@Poincut可以在一个切面内定义可重用的切点： 1234567891011121314151617181920212223242526272829303132package com.ljc.concert;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience&#123; //定义切点 @Pointcut("execution(**com.ljc.concert.Performance.perform(..))") public void performance()&#123;&#125; //表演之前 @Before("performance()") public void silenceCellPhones()&#123; System.out.println("Silencing Cell Phones..."); &#125; @Before("performance()") public void takeSeats() &#123; System.out.println("Taking seats..."); &#125; //表演之后 @AfterReturning("performance()") public void applause()&#123; System.out.println("Clap..."); &#125; //表演失败之后 @AfterThrowing("performance()") public void demandRefound()&#123; System.out.println("Demanding a refund..."); &#125;&#125; 1.1 在JavaConfig中启用AspectJ注解的自动代理 使用javaConfig的话，可以在配置类的类级别上通过使用EnbleAspectJ-AutoProxy注解启用自动代理功能：123456789101112131415161718package com.ljc.concert;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;//启用AspectJ自动代理@Configuration@EnableAspectJAutoProxy@ComponentScanpublic class ConcertConfig &#123; //声明Audience bean @Bean public Audience audience()&#123; return new Audience(); &#125;&#125; 1.2 在XML中，通过spring的aop命名空间启用AspectJ注解的自动代理 使用spring aop命名空间的aop:aspectj-autoproxy元素：123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/beans/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.ljc.concert"/&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;bean class="com.ljc.concert.Audience"/&gt; &lt;/beans&gt; 2. 创建环绕通知 环绕通知是最为强大的通知类型，它能够让你所编写的逻辑将被通知的目标方法完全包装起来，就像在一个方法中通知编写了前置和后置通知，用环绕通知重写Audience切面：1234567891011121314151617181920package com.ljc.concert;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;@Aspectpublic class Audience&#123; //定义切点 @Pointcut("execution(**com.ljc.concert.Performance.perform(..))") public void performance()&#123;&#125; //环绕通知 @Around("performance()") public void watchPerformance(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println("Silencing Cell Phones..."); System.out.println("Taking seats..."); jp.proceed(); System.out.println("Clap..."); System.out.println("Demanding a refund..."); &#125; 在XML中声明切面 原则：基于注解的配置要优于基于java的注解的配置，基于java的配置要优于基于XML的配置。但是，需要声明切面，但是又不能为通知类添加注解的通知，那么就必须转向XML配置了。 1.声明前置通知和后置通知1.1 通过XML将无注解的Audience声明为切面123456789101112131415161718192021&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:before pointcut="execution(** com.ljc.concert.Performance.perform(..))" method="silencePhone"/&gt; &lt;aop:before pointcut="execution(** com.ljc.concert.Performance.perform(..))" method="takeSeats"/&gt; &lt;aop:after-returning pointcut="execution(** com.ljc.concert.Performance.perform(..))" method="applause"/&gt; &lt;aop:after-throwing pointcut="execution(** com.ljc.concert.Performance.perform(..))" method="demandRefound"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 大多数的配置必须在aop：config的上下文内使用，我们可以声明一个或者多个通知器，切面或者切点。ref元素引用了一个POJO bean，该bean实现了切面的功能（这里就是audience），ref元素所引用的bean提供了在切面中通知被调用的方法。 1.2 使用aop：pointcut定义命名切点12345678910111213141516171819202122232425&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:pointcut id="performance" expression="execution(** com.ljc.concert.Performance.perform(..)"/&gt; &lt;aop:before pointcut-ref="performance" method="silencePhone"/&gt; &lt;aop:before pointcut-ref="performance" method="takeSeats"/&gt; &lt;aop:after-returning pointcut-ref="performance" method="applause"/&gt; &lt;aop:after-throwing pointcut-ref="performance" method="demandRefound"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 2. 声明环绕通知 相对于前置通知和后置通知，环绕通知有明显的优势，它可以完成前置通知和后置通知的所实现的相同功能，而且只需要在一个方法中声明，使用aop：around元素就可以：12345678910111213&lt;aop:config&gt; &lt;aop:aspect ref="audience"&gt; &lt;aop:pointcut id="performance" expression="execution(** com.ljc.concert.Performance.perform(..)"/&gt; &lt;aop:around pointcut-ref="performance" method="watchPerformance"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 注入AspectJ切面 虽然spring AOP能够满足许多应用的切面需求，但是与AspectJ相比，spring AOP是一个功能相对较弱的AOP解决方案，AspectJ提供了许多spring AOP所不能支持的许多类型的切点。新建一个切面CriticAspect，主要职责就是在表演结束之后给出意见： 123456789101112131415161718package com.ljc.concert;public aspect CriticAspect &#123; public CriticAspect()&#123;&#125; pointcut:performance():execution(*perform(..)); afterReturning():performance()&#123; System.out.println(criticismEngine.getCriticism()); &#125; private CriticismEngine criticismEngine; public void setCriticismEngine(CriticismEngine criticismEngine)&#123; this.criticismEngine=criticismEngine; &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫--基于java]]></title>
    <url>%2F2019%2F08%2F13%2F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB-%E5%9F%BA%E4%BA%8Ejava%2F</url>
    <content type="text"><![CDATA[网络爬虫介绍什么是网络爬虫 网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 网络爬虫是一个自动提取网页的程序，它为搜索引擎从万维网上下载网页，是搜索引擎的重要组成。传统爬虫从一个或若干初始网页的URL开始，获得初始网页上的URL，在抓取网页的过程中，不断从当前页面上抽取新的URL放入队列,直到满足系统的一定停止条件。聚焦爬虫的工作流程较为复杂，需要根据一定的网页分析算法过滤与主题无关的链接，保留有用的链接并将其放入等待抓取的URL队列。然后，它将根据一定的搜索策略从队列中选择下一步要抓取的网页URL，并重复上述过程，直到达到系统的某一条件时停止。另外，所有被爬虫抓取的网页将会被系统存贮，进行一定的分析、过滤，并建立索引，以便之后的查询和检索；对于聚焦爬虫来说，这一过程所得到的分析结果还可能对以后的抓取过程给出反馈和指导。 入门程序1.在pom.xml添加配置文件 httpClient：https://mvnrepository.com/search?q=httpclient 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt; &lt;/dependency&gt; slf4j:https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 1234567&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2.创建log4j.properties文件：123456log4j.rootLogger=DEBUG,A1log4j.logger.com.ljc=DEBUGlog4j.appender.A1=org.apache.log4j.ConsoleAppenderlog4j.appender.A1.layout=org.apache.log4j.PatternLayoutlog4j.appender.A1.layout.ConversionPattern=%-d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;[%t] [%c]-[%p] %m%n 3.代码：1234567891011121314151617181920212223242526272829303132package com.ljc.crawler.test;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import java.io.IOException;public class CrawlerFirst &#123; public static void main(String[] args) throws IOException &#123; //1.打开浏览器，创建HttpClient对象 CloseableHttpClient httpClient= HttpClients.createDefault(); //2.输入网址，发起get请求创建HttpGet对象 HttpGet httpGet=new HttpGet("http://www.baidu.com"); //3.按回车，发起请求，返回响应，使用HttpClient对象发起请求 CloseableHttpResponse response=httpClient.execute(httpGet); //4.解析响应，获取数据 //判断状态码是否为200 if(response.getStatusLine().getStatusCode()==200)&#123; HttpEntity httpEntity=response.getEntity(); String content= EntityUtils.toString(httpEntity,"utf8"); System.out.println(content); &#125; &#125;&#125; HttpClient1. Get请求：带参数12345678910//设置请求地址是：http://yun.itheima.com/search?keys=java //创建URINuilder URIBuilder uriBuilder=new URIBuilder("http://yun.itheima.com/search?keys=java"); //设置参数 uriBuilder.setParameter("keys","java"); //创建HttpGet对象，设置URL地址 HttpGet httpGet=new HttpGet(uriBuilder.build()); System.out.println("发起请求的信息："+httpGet); 如果是无参数的GET请求，则直接使用构造方法 HttpGet(String url) 创建HttpGet对象即可；如果是带参数GET请求，则可以先使用URIBuilder(String url) 创建对象，再调用addParameter(String param, String value)，或setParameter(String param, String value)来设置请求参数，并调用build()方法构建一个URI对象。只有构造方法HttpGet(URI uri)来创建HttpGet对象。 2.POST请求：带参数1234567891011121314//创建HttpPost对象，设置URL地址 HttpPost httpPost=new HttpPost("http://yun.itheima.com/search"); //声明List集合：封装表单中的参数 List&lt;NameValuePair&gt; params=new ArrayList&lt;NameValuePair&gt;(); params.add(new BasicNameValuePair("keys","java")); //创建表单的Entity对象 UrlEncodedFormEntity formEntity=new UrlEncodedFormEntity(params,"utf8"); //设置表单的Entity实体对象到Post请求中 httpPost.setEntity(formEntity); System.out.println("发起请求的信息："+httpPost); 如果是无参数的GET请求，则直接使用构造方法HttpPost(String url)创建HttpPost对象即可；如果是带参数POST请求，先构建HttpEntity对象并设置请求参数，然后调用setEntity(HttpEntity entity)创建HttpPost对象 3.连接池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 package com.ljc.crawler.test;import org.apache.http.HttpEntity;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.util.EntityUtils;import java.io.IOException;/** * @author 林军成 * @data -13:11 */public class HttpPoolTest &#123; public static void main(String[] args) &#123; //创建连接池管理器 PoolingHttpClientConnectionManager cm=new PoolingHttpClientConnectionManager(); //设置连接数 cm.setMaxTotal(100); //设置每个主机的最大连接数 cm.setDefaultMaxPerRoute(10); //使用连接池管理器发起请求 doGet(cm); doGet(cm); &#125; private static void doGet(PoolingHttpClientConnectionManager cm) &#123; //不是每次创建新的HttpClient，而是从连接池中获取HttpClient对象 CloseableHttpClient httpClient= HttpClients.custom().setConnectionManager(cm).build(); HttpGet httpGet=new HttpGet("http://www.csdn.net"); //使用HttpClient发起请求，获取response CloseableHttpResponse response=null; try &#123; response = httpClient.execute(httpGet); //解析响应 if (response.getStatusLine().getStatusCode() == 200) &#123; HttpEntity httpEntity = response.getEntity(); String content = EntityUtils.toString(httpEntity, "utf8"); System.out.println(content.length()); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125;finally &#123; if(response!=null)&#123; try&#123; // 关闭response,不能关闭HttpClient response.close(); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 4.请求参数 有时候因为网络或者目标服务器的原因，请求需要很长的时间才能完成，我们需要自定义相关时间1234567//配置请求信息 RequestConfig config=RequestConfig.custom().setConnectTimeout(1000) //创建连接的最长时间，单位是毫秒 .setConnectionRequestTimeout(500) //设置获取连接的最长时间，单位是毫秒 .setSocketTimeout(10*1000) //设置数据传输的最长时间，单位是毫秒 .build(); //给请求设置请求信息 httpGet.setConfig(config);]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring高级装配]]></title>
    <url>%2F2019%2F08%2F13%2Fspring%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[spring高级装配 spring profile 1.配置profile bean 在3.1版本中，spring引入了spring profile的功能。要使用profile，首先要将所有不同的bean定义整理到一个或多个profile中，在将应用部署到每个环境中，要保证对应得profile处于激活（active）状态。 1.1 java中配置profile 可以使用@Profile注解指定某一个bean属于哪一个profile。例如，在配置类中，嵌入式数据库的DataSource可能会配置成这样：12345678910111213141516package com.ljc.myapp;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import javax.sql.DataSource;@Configuration@Profile("dev")public class DevelopmentProfileConfig &#123; @Bean(destroyMethod = "shutdown") public DataSource dataSource()&#123; return new ... &#125;&#125; @Profile应用在类级别上，它会告诉spring这个配置类的bean只有在dev profile激活时才会创建。如果dev profile没有激活的话，那么带有@Bean注解的方法都会被忽略掉。 在spring3.1中，只能在类级别上使用@Profile注解，不过，从spring3.2开始，也可以在方法级别使用@Profile注解，与@bean一同使用。这样就能将这个bean的声明放到同一个配置类中。 1.2 在XML中配置profile 可以使用bean元素的profile属性，在XML中配置profile bean。例如，在XML中定义适用于开发阶段的嵌入式数据库DataSource bean，可以创建如下的XML文件： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xsi:schemaLocation=" http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd" profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource"&gt; &lt;jdbc:script location="classpath:schema.sql"/&gt; &lt;jdbc:script location="classpath:test-data.sql"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 2.激活profile spring在确定哪个profile处于激活状态时，需要依赖两个独立的属性：spring。profile。active和spring。profile。default。如果设置了spring。profile。active的值，它的值就会用来确定哪个profile是激活的。但如果没有设置spring。profile。active属性的话，那么spring就会查找spring。profile。default的值，如果都没有设置的话，那就没有激活的profile，那就只能创建那些没有定义在profile的bean。 条件化的bean 如果希望一个或者多个bean只有在应用的类路径下包含特定的库时才创建。或者希望某个bean只有在当另外的特定的bean也声明了之后才会创建，还可能要求某个环境变量设置之后，才会创建某个bean。在spring4之前很难实现这种操作，但是spring4引入了一个新的注解@Conditionnl，它可以用到带有@Bean注解的方法上，弱国给定的结果为true，就会创建这个bean，否则的话，这个bean会被忽略。 1.条件化的配置bean12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean()&#123; return new MagicBean();&#125; 可以看到，@Conditional给定了条件–MagicExistsCondition。@Conditional将会通过Condition接口进行条件对比; 123public interface Condition &#123; boolean matchs(ConditionContext ctxt, AnnotatedTypeMetadata metadata)&#125; 如果 matchs（）方法返回true，那么就会创建带有@Conditional注解的bean，如果返回false，则不会创建这些bean 2.检查是否存在某属性 在本例中，我们需要创建Condition的实现，并根据环境中是否存在magic属性来做决策：12345678910111213141516package com.ljc.myapp;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.type.AnnotatedTypeMetadata;import sun.tools.java.Environment;public class MagicExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env=context.getEnvirment; return env.containsProperty("magic"); &#125;&#125; matchs()方法很简单但功能强大，它通过给定的ConditionContext对象得到Environment对象，并用这个对象检查环境是否存在magic属性，属性的值是什么无所谓，只要满足条件就可以，满足就返回true，否则返回false ConditionContext接口： 12345678910111213public interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); @Nullable ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); @Nullable ClassLoader getClassLoader();&#125; 通过ConditionContext接口，可以做到如下几点： 借助getRegistry()返回的BeanDefinitionRegistry检查bean定义 借助getBeanFactory()返回的ConfigurableListableBeanFactory 检查bean是否存在，甚至探查bean的属性 借助getEnvironment()返回的Environment检查环境变量是否存在以及它的值是什么 读取并探查getResourceLoader()返回的ResourceLoader所加载的资源 借助getClassLoader()返回的ClassLoader加载并检查类是否存在 AnnotatedTypeMetadata接口： 123456789101112131415public interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1); @Nullable Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); @Nullable MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 借助isAnnotated方法，能够判断带有@Bean注解的方法是不是还有其他特定的注解。借助其他方法，能够检查@Bean注解的方法上其他的注解的属性 处理自动装配的歧义性 当发生歧义性时，spring提供了多种可选的方案来解决这样的问题。可以将某个bean设为首选（primary）的bean，或者使用限定符（qualifier）来帮助spring将可选的范围缩小到只有一个。 1.标示首选的bean 下面的代码显示了如何将@Component注解的bean声明为首选的bean 123@Component()@Primarypublic class SgtPeppers implements CompactDisc &#123; 通过java代码显示的声明，那么@Bean的方法如下： 123456@Bean@Primary@Conditional(MagicExistsCondition.class)public MagicBean magicBean()&#123; return new MagicBean();&#125; 如果使用XML配置的话，bean元素有一个primary属性用来指定首选的bean： 123&lt;bean id="CompactDisc" class="com.ljc.soundsystem.SgtPeppers" primary="true"/&gt; 2.限定自动装配的bean 确保将CompactDisc注入到setCompactDisc中：12345@Autowired @Qualifier("CompactDisc") public void setCompactDisc(CompactDisc compactDisc)&#123; this.compactDisc=compactDisc; &#125; bean的作用域 在默认情况下，spring应用上下文中的所有bean都是作为以单例（singleton）模式创建的，也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。spring定义了多种作用域，可以基于这些作用域创建bean，包括： 单例（singleton）：在整个应用中，只创建bean一个实例； 原型（propotype）：每次注入或者通过spring应用上下文获取的时候，都会创建一个新的bean实例； 会话（session）：在Web应用中，为每个会话创建一个bean； 请求（Rquest）：在web应用中，为每个请求创建一个bean； 单例是默认的，如果选择其他的作用域，要使用@Scope注解，可以和@Bean或@Component注解一起使用]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的核心---spring容器]]></title>
    <url>%2F2019%2F08%2F12%2FSpring%E7%9A%84%E6%A0%B8%E5%BF%83%2F</url>
    <content type="text"><![CDATA[spring的核心—spring容器spring基本概念 什么是spring框架 Spring是一个开源框架，Spring是于2003 年兴起的一个轻量级的Java 开发框架，由Rod Johnson 在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。Spring使用基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE/EE full-stack(一站式) 轻量级开源框架。 spring的体系结构 spring框架是一个分层架构，包含一系列的功能要素，被分为大约20个模块。这些模块分为Core Container，Data Access/Integration,Web,AOP,测试部分 让我们逐一浏览spring模块 spring核心容器—管理着bean的创建，配置和管理 bean 工厂：为spring提供DI的功能 应用上下文：提供了配置spring的方式 spring的AOP模块—面向切面编程 AOP：帮助应用对象解耦 数据访问与集成 JDBC：抽象了板式代码，使数据库代码变得简洁明了 ORM：对许多流行的ORM框架进行了集成，例如Hibernate。spring的事务管理支持所有的ORM框架以及JDBC JMS：使用消息以异步的方式与其他应用集成，从spring3.0开始，本模块还包含对象到XML映射的特性 Web与远程调用—MVC（Model-View-Controller）Instrumentation 提供了为JVM添加代理的功能。具体来讲，为Tomcat提供了一个植入代理，能够为Tomcat传递类文件，就像这些文件是被类加载器加载的一样 测试 为使用JNDI，Servlet和Portlet编写单元提供了一些列的mock对象实现 装配Bean 在XML中进行显示配置 在java中进行显示配置 隐式的bean发现机制和自动装配 自动化装配bean：组件扫描和自动装配1.创建可被发现的bean 1.1 CompactDisc接口定义了CD的概念 12345package com.ljc.soundsystem;public interface CompactDisc &#123; void play();&#125; 1.2 带有@Component注解的CompactDisc实现类SgtPeppers 12345678910111213package com.ljc.soundsystem;import org.springframework.stereotype.Component;@Componentpublic class SgtPeppers implements CompactDisc &#123; private String title="Sgt.Pepeers's Lonely Hearts Club Band"; private String artist="The Beatles"; public void play() &#123; System.out.println("Playing"+title+"by"+artist); &#125;&#125; @Compoment注解：表明该类会作为组件类，并告知spring要为这个类创建bean 1.3 @ComponentScan注解启用了组件扫描—组件扫描默认是不开启的，需要显示配置一下spring，从而命令它去寻找带有@Component注解的类，并为其创建bean 123456789package com.ljc.soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig &#123;&#125; 2. 为组件扫描的bean命名 2.1&nbsp;&nbsp;spring给所有的bean都有一个ID。在前面的例子中，我们没有为SgtPeppersbean设置ID，但spring会根据类名为其指定一个ID，为sgtPeppers，也就是类名的第一个字母变为小写 2.2&nbsp;&nbsp;方法1：将期望的ID值传递给@Component注解。例如想让这个标识为lin，只需要像下面配置： 123@Component("lin")public class SgtPeppers implements CompactDisc &#123; ...&#125; 2.3&nbsp;&nbsp;方法2：不适用@Component注解，而是使用java依赖注入规范中的@Named注解为bean设置ID 3.通过为bean添加注解实现自动装配 3.1&nbsp;&nbsp;通过自动装配，将一个CompactDisc注入到CDPlayer之中 1234567891011121314151617181920package com.ljc.soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScanpublic class CDPlayerConfig &#123; private CompactDisc cd; @Autowired public CDPlayerConfig(CompactDisc cd)&#123; this.cd=cd; &#125; public void play()&#123; cd.play(); &#125;&#125; 3.2&nbsp;&nbsp;构造器上加了@Autowired注解，表明当spring创建CDPlayerConfigbean时，会通过这个构造器来进行实例化并传入一个可以设置给CompactDisc类型的bean。@Autowired不仅适用构造器，也适用其他方法 3.3&nbsp;&nbsp;如果没有匹配的bean，spring会抛出一个异常。为了避免异常，可以将@Autowired的required属性设为false： 1234@Autowired(required = false) public CDPlayerConfig(CompactDisc cd)&#123; this.cd=cd; &#125; -3.4&nbsp;&nbsp;可以用@Inject替换@Autowired，spring可以同时支持两种 通过java代码装配bean1.创建配置类12345678package com.ljc.soundsystem;import org.springframework.context.annotation.Configuration;@Configurationpublic class CDPlayerConfig &#123;&#125; @Configuration注解表明这个类是一个配置类，该类包含在spring应用上下文如何创建bean的细节 2.声明简单的bean-2.1&nbsp;在javaConfig中声明bean，需要编写一个方法，这个方法负责创建所需类型的实例，然后给这个方法添加@Bean注解。例如，下面的代码声明了CompactDisc bean： 1234@Bean public CompactDisc sgtPeppers()&#123; return new SgtPeppers(); &#125; -2.2&nbsp;@Bean注解会告诉spring这个方法会返回一个对象，该对象要注册为spring上下文中的bean。默认下，bean的ID与带有@Bean注解的方法一样，本例中，bean的ID为sgtPeppers。 3.借助javaConfig实现注入 通过XML装配bean1.创建XML配置规范12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context"&gt; &lt;!-- configuration details go here--&gt;&lt;/beans&gt; 以bean元素为根，需要在顶部声明多个XML模式（XSD）文件，这些文件定义了配置spring的XML元素 2.声明一个简单的bean 2.1&nbsp;bean元素相当于JavaConfig的@Bean注解，可以按照如下方法声明一个bean：1&lt;bean class="com.ljc.soundsystem.SgtPeppers"/&gt; -因为没有给定ID，所以这个bean会根据类名来进行命名。在本例中，bean的ID将会是“soundsystem.SgtPeppers#0”.其中#0是一个计数的形式，用来区分相同类型的bean。如果声明了另外一个SgtPeppers，并且没有明确的标识，那么它会自动得到ID：“soundsystem.SgtPeppers#1” 2.2更好的方法是借助id属性，为每一个bean设置成自己选择的ID： 1&lt;bean id="CompactDisc" class="com.ljc.soundsystem.SgtPeppers"/&gt; 3.借助构造器初始化注入bean 构造器注入，有两种基本的配置方案：a.constructor-arg元素&nbsp;&nbsp;b.使用spring3.0引入的c-命名空间 3.1已经声明了SgtPeppers bean，并且SgtPeppers类实现了CompactDisc接口，所以我们已经有了一个可以注入到CDPlayer bean的bean。只需要在XML中声明CDPlayer并通过ID引用SgtPeppers： 123&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayerConfig"&gt; &lt;constructor-arg ref="CompactDisc"/&gt; &lt;/bean&gt; &nbsp;&nbsp;当spring遇到这个bean元素时，它会创建一个CDPlayer实例。constructor-arg会告诉spring要将一个ID为CompactDisc的bean引用传递到CDPlayer的构造器中 3.2 也可以使用费c-命名空间，必须在XML的顶部声明： 123456&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:c="http://www.springframework.org/schema/c" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context"&gt; 声明如下： 12&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayerConfig" c:cd-ref="CompactDisc"/&gt; 4.设置属性 4.1 CDPlayer如下：1234567891011121314151617package com.ljc.soundsystem;import org.springframework.beans.factory.annotation.Autowired;public class CDPlayer implements MediaPlayer&#123; private CompactDisc compactDisc; @Autowired public void setCompactDisc(CompactDisc compactDisc)&#123; this.compactDisc=compactDisc; &#125; public void play()&#123; compactDisc.play(); &#125;&#125; &nbsp;&nbsp;对强依赖使用构造器注入，对可选性的以来使用属性注入。将其声明为spring bean： 1234&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayer"&gt; &lt;property name="compactDisc" ref="CompactDisc"/&gt; &lt;/bean&gt; &nbsp;&nbsp;property元素为属性的Setter方法提供的功能与constructor-arg元素为构造器提供的功能是一样的。在本例中，它引用了ID为compactDisc的bean（通过ref属性），并将其注入到compactDisc属性中（通过setCompactDisc（）方法） 4.2 上文说过，spring为constructor-arg元素提供了c-命名空间，同样，spring提供了更加简洁的p-命名空间作为property的代替方案。为了启用p-命名空间，必须要在XML的顶部声明： 1xmlns:p="http://www.springframework.org/schema/p" 可以使用p-命名空间，按照如下的方式装配compactDisc属性：123&lt;bean id="cdPlayer" class="com.ljc.soundsystem.CDPlayer" p:compactDisc-ref="CompactDisc"/&gt; 小结 建议尽可能使用自动化配置，以避免显示配置所带来的维护成本。但是，当我们确实需要显示配置的话，应该优先选择基于java的配置，它比基于XML的配置更加强大，类型安全并且易于重构。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习路线]]></title>
    <url>%2F2019%2F08%2F11%2Fjava%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[java的学习路线基础知识 编程语言：java 基本算法 基本网络知识：TCP/IP HTTP/HTTPs 基本的设计模式 工具方面 操作系统：Linux 代码管理：SVN/git 持续集成（CI/CD）：jenkins java项目管理工具：maven 框架方面应用层框架 ssh：spring+structs+hibernate ssm：spring+springMVC+mybatis springboot 中间件 MQ 消息队列 RPC 通信框架 elasticserach 搜索引擎 数据库 SQL：MYSQL/oracle NOSQL： Redis mongodb 架构方面分布式/微服务 springcloud dubbo 虚拟化/容器化技术 Docker 容器 K8S kubernetes 关注源码/性能 JDK 源码以及设计思想 spring 源码 JVM 细节 高并发/高可用]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
